# -*- coding: utf-8 -*-

require File.expand_path('instance', File.dirname(__FILE__))

class Pentestenv
  # Pentest-env Customizations
  class Customization
    def initialize(custom)
      @logger = Log4r::Logger.new('vagrant::pentest-env/customizations')
      @logger.info("Pentest-env customizations: #{custom}")
      @custom = custom
    end

    def register(config, type='instances')
      return unless @custom.key?(type)

      @custom[type].each do |i|
        instance = Pentestenv::Instance.new(config, i.chomp, type[0...-1], @custom)
        instance.register
        apply instance.name, config
      end
    end


    def apply(instance_name, config)
      @logger.info("[#{instance_name}] Applying customizations..")
      packages instance_name, config
      autostart instance_name, config
      commands instance_name, config
      scripts instance_name, config
      synced_folders instance_name, config
      networks instance_name, config

      apply_vbox instance_name, config
      apply_docker instance_name, config
      apply_openstack instance_name, config

      apply_chef instance_name, config
    end

    def autostart(instance_name, config)
      autostart = instance_customization(instance_name, 'autostart')
      return if autostart == nil

      @logger.info("[#{instance_name}] Set autostart: #{autostart ? 'on' : 'off'}")
      config.vm.define instance_name, autostart: autostart
    end

    def packages(instance_name, config)
      packages = instance_customization(instance_name, 'packages')
      return unless packages and not packages.empty?

      config.vm.define instance_name do |i|
        @logger.info("[#{instance_name}] Setup packages: `#{packages.join(' ')}`")
        i.vm.provision :shell,
                          inline: 'apt-get update&&'\
                                  "apt-get -y install #{packages.join(' ')}"
      end
    end

    def commands(instance_name, config)
      commands = instance_customization(instance_name, 'commands')
      return unless commands

      config.vm.define instance_name do |i|
        commands.each do |command|
          @logger.info("[#{instance_name}] Setup provisioning inline script (command): `#{command}`")
          i.vm.provision :shell,
                         inline: command
        end
      end
    end

    def scripts(instance_name, config)
      scripts = instance_customization(instance_name, 'scripts')
      return unless scripts

      config.vm.define instance_name do |i|
        scripts.each do |script|
          path = script_path(script)
          next unless path
          @logger.info("[#{instance_name}] Setup provisioning shell script: `#{path}`")
          i.vm.provision :shell,
                         path: path
        end
      end
    end

    def synced_folders(instance_name, config)
      folders = instance_customization(instance_name, 'synced_folders')
      return unless folders

      config.vm.define instance_name do |i|
        folders.each do |host, guest|
          @logger.info("[#{instance_name}] Configure volume: `#{host}` => `#{guest}`")
          i.vm.synced_folder(host, guest)
        end
      end
    end

    def networks(instance_name, config)
      networks = instance_customization(instance_name, 'networks')
      return unless networks

      config.vm.define instance_name do |i|
        networks.each do |type, netconfig|
          @logger.info("[#{instance_name}] Configure #{type}: #{netconfig}")
          i.vm.network(type.to_sym, hash_keys_to_symbols(netconfig))
        end
      end
    end

    def apply_vbox(instance_name, config)
      vconf = instance_customization(instance_name, 'vbox')
      return unless vconf

      config.vm.define instance_name do |i|
        i.vm.provider :virtualbox do |vbox|
          vconf.each do |key, value|
            if key == 'customize'
              value.each do |k, v|
                @logger.info("[#{instance_name}] Customize vbox: `#{k}` => `#{v}`")
                vbox.customize ['modifyvm', :id, "--#{k}", v]
              end
            else
              @logger.info("[#{instance_name}] Configure vbox: `#{key}` => `#{value}`")
              vbox.send("#{key}=", value)
            end
          end
        end
      end
    end

    def apply_chef(instance_name, config)
      if File.directory? "#{ENV['PWD']}/chef-repo/roles"
        chef_custom = instance_customization(instance_name, 'chef')
        return unless chef_custom

        chef_base_url = 'https://opscode-omnibus-packages.s3.amazonaws.com/debian/8/x86_64'
        chef_deb_file = 'chef_12.8.1-1_amd64.deb'

        config.vm.define instance_name do |i|
          i.vm.provision :shell,
                         inline: 'test -d /opt/chef ||'\
                                 "(wget #{chef_base_url}/#{chef_deb_file} -O #{chef_deb_file} && "\
                                 "dpkg -i #{chef_deb_file} && rm #{chef_deb_file})"

          i.vm.provision :chef_solo do |chef|
            chef.install = false
            chef.cookbooks_path = 'cookbooks/'
            chef.roles_path = 'chef-repo/roles'

            if chef_custom['recipes']
              chef_custom['recipes'].each do |recipe|
                @logger.info("[#{instance_name}][chef] Add recipe `#{recipe}`")
                chef.add_recipe(recipe)
              end
            end

            if chef_custom['roles']
              chef_custom['roles'].each do |role|
                @logger.info("[#{instance_name}][chef] Add role `#{role}`")
                chef.add_role(role)
              end
            end

            chef.json = chef_custom['json'] if chef_custom['json']
          end
        end
      end
    end

    def apply_docker(instance_name, config)
      dconf = instance_customization(instance_name, 'docker')
      return unless dconf

      config.vm.define instance_name do |i|
        i.vm.provider :docker do |d|
          dconf.each do |k, v|
            @logger.info("[#{instance_name}] Set Docker config: `#{k}` => `#{v}`")
            d.send("#{k}=", v)
          end
        end
      end
    end

    def apply_openstack(instance_name, config)
      os = instance_customization(instance_name, 'openstack')
      return unless os

      config.vm.define instance_name do |i|
        i.vm.provider :openstack do |d|
          os.each do |k, v|
            @logger.info("[#{instance_name}] Set Openstack config: `#{k}` => `#{v}`")
            d.send("#{k}=", v)
          end
        end
      end
    end

    private

    def script_path(script)
      script_path = false
      default_path = "#{ENV['PWD']}/scripts/#{script}"
      custom_path = "#{@custom['scripts_path']}/#{script}"
                    .gsub(/^~/, ENV['HOME'])

      if @custom.key?('scripts_path') \
         && ! @custom['scripts_path'].empty? && File.exist?(custom_path)
        script_path = custom_path
      elsif File.exist?(default_path)
        script_path = default_path
      end

      @logger.debug("Script path for `#{script}`: `#{script_path}`")
      script_path
    end

    def instance_customization(name, key)
      customizations = nil
      if @custom.key?(name)\
         && @custom[name].key?(key)
        customizations = @custom[name][key]
      end

      @logger.debug("[#{name}][#{key}] => `#{customizations.to_s}`")
      customizations
    end

    def hash_keys_to_symbols(hash)
      return hash if not hash.is_a?(Hash)
      hash.inject({}){|memo,(k,v)| memo[k.to_sym] = hash_keys_to_symbols(v); memo}
    end
  end
end
